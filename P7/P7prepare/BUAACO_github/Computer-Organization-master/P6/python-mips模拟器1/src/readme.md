# 踩过得坑

## 数据结构设计

输入的是二进制，01字符串，果断需要字符串切割啊

参考 2 4 5 5 5 5 6的分割分别对应`flag` ,`opCode` ,`rs`,`rt`,`rd`,`shiftAmts`,`functionCode`.这样分割基本差不离了，其他的就是他们之间的随意组合了

```python
    currentAddress = [256] # 地址从256开始
    instructions = read_bin(outputFileName) # 获取所有的指令集
    flags = [] # 标志位，判断属于哪一类标志
    opCodes = [] # 操作码
    rs = [] # 源寄存器
    rt = [] # 源寄存器 
    rd = [] # 目的寄存器
    shiftAmts = [] # 在移位指令中表示移位
    functionCodes = [] # 功能码
    regValues = [0] * 32 # 保存32个寄存器 32个寄存器用5个二进制表示
    memoryValues = [0] * 60 # 保存内存值
```

这样一条指令就被分割成
`(flag,opcode,rs,rt,rd,shiftAmts,functionCode)`由于保存成一个元组或者字典处理起来没有list方便，我就保存成了list的形式

内存值和寄存器值得变化就不谈了。寄存器题目中说了一共32个，内存值自己设置就行，只要满足条件就OK了

## switch-case

python中没有switch-case形式，造一个
```python
# J
def case_J(rs, rt, rd, shiftAmt, functionCode):
    instructionArgs = '#'
    # 需要左移2位
    instructionArgs = '#' + str(int(rs + rt + rd + shiftAmt + functionCode, base=2) << 2)
    return instructionArgs

# JR
def case_JR(rs, rt, rd, shiftAmt, functionCode):
    instructionArgs = getRegName(rs)
    return instructionArgs
...
switch={
    'J':case_J,
    'JR':case_JR,
    'BEQ':case_BEQ,
    'BLTZ':case_BEQ,
    'BGTZ':case_BGTZ,
    'BREAK':case_BREAK,
    'SW':case_SW,
    'LW':case_LW,
    'SLL':case_SLL,
    'SRL':case_SRL,
    'SRA':case_SRA,
    'NOP':case_NOP,
    'ADD':case_ADD,
    'SUB':case_SUB,
    'MUL':case_MUL,
    'AND':case_AND,
    'OR':case_OR,
    'XOR':case_XOR,
    'NOR':case_NOR,
    'SLT':case_SLT,
    'ADDI':case_ADDI,
    'ANDI':case_ANDI,
    'ORI':case_ORI,
    'XORI':case_XORI,
}

# 调用
switch[instructionName](rs, rt, rd, shiftAmt,functionCode)
```

## 注意里面有几个需要移位和考虑溢出的地方

BEQ BLTZ BGTZ J 需要考虑移位


## 计算反码
```
 一、已知的二进制是以0开头的二进制补码：

也就是说这个二进制补码的左边最高位是以0开头的。最高位是0，在在二进制补码中表示该数是正数。而正的二进制补码与十进制的对应关系是最简单的，直接按照二进制与十进制的对应转换法则转换就行了（这里需要你知道二进制与十进制相互转换的知识）。
 
 例如：已知二进制补码：001110、011010、011、01010、01110010，求与之对应十进制。
001110：（+0）* （2^5） + 0*（2^4） + 1*（2^3） + 1*（2^2） + 1*（2^1） + 0*（2^0） = 14；
 
011010：：（+0）* （2^5） + 1*（2^4） + 1*（2^3） + 0*（2^2） + 1*（2^1） + 0*（2^0） = 26；
 
011：（+0）*（2^2） +1*（2^1） + 1*（2^0） = 3；
 
01010：（+0）*（2^4） + 1*（2^3） + 0*（2^2） + 1*（2^1） + 0*（2^0） = 10；
 
01110010：（+0）* （2^7） + 1*（2^6） +1* （2^5） + 1*（2^4） + 0*（2^3） + 0*（2^2） + 1*（2^1） + 0*（2^0） = 114；
 二、已知的二进制是以1开头的二进制补码：

也就是说这个二进制补码的左边最高位是以1开头的。最高位是0，在在二进制补码中表示该数是负数。而负的二进制补码与十进制的对应关系是稍微复杂的，有三种方法来求其对应的十进制数。
第一种方法是这样的，既然知道该数是负的，我们可以直接把左边最高位的符号位抛弃，然后把剩下的二进制每一位都取反，然后取反以后的数值+1，得到的数就是此负的二进制补码的绝对值了，我们直接把此绝对值按照二进制与十进制的对应转换法则转换就行了，在转换得到的十进制前面加一个负号，于是我们就得到了这负的二进制补码对应的十进制数。
 例如：已知二进制补码：101110、111010、111、1010、11110010，求与之对应十进制。
101110去符号位01110取反10001加一10010十进制18加负号-18；
 
111010去符号位11010取反00101加一00110十进制6加负号-6；
 
111去符号位11取反00加一01十进制1加负号-1；
 
1010去符号位010取反101加一110十进制6加负号-6；
 
11110010去符号位1110010取反0001101加一0001110十进制14加负号-14；

第二种方法与第一个方法十分相似，直接把整个负的二进制补码的每一位都取反，然后取反以后的数值+1，得到的数就是此负的二进制补码的绝对值了，我们直接把此绝对值按照二进制与十进制的对应转换法则转换就行了，在转换得到的十进制前面加一个负号，于是我们就得到了这负的二进制补码对应的十进制数。
 例如：已知二进制补码：101110、111010、111、1010、11110010，求与之对应十进制。
101110取反010001加一010010十进制18加负号-18；
 
111010取反000101加一000110十进制6加负号-6；
 
111取反000加一001十进制1加负号-1；
 
1010取反0101加一0110十进制6加负号-6；
 
11110010取反00001101加一00001110十进制14加负号-14；
 第三种方法更是直接，方法和处理正的二进制补码一样，唯一的区别是正数以0开头，负数以1开头，我们把（+0）改成（-1）便可，这里不赘述，直接上例子，一看便知。
 例如：已知二进制补码：101110、111010、111、11010、11110010，求与之对应十进制。
101110：（-1）* （2^5） + 0*（2^4） + 1*（2^3） + 1*（2^2） + 1*（2^1） + 0*（2^0） = -18；
 
111010：：（-1）* （2^5） + 1*（2^4） + 1*（2^3） + 0*（2^2） + 1*（2^1） + 0*（2^0） = -6；
 
111：（-1）*（2^2） +1*（2^1） + 1*（2^0） = -1；
 
11010：（-1）*（2^4） + 1*（2^3） + 0*（2^2） + 1*（2^1） + 0*（2^0） = -6；
 
11110010：（-1）* （2^7） + 1*（2^6） +1* （2^5） + 1*（2^4） + 0*（2^3） + 0*（2^2） + 1*（2^1） + 0*（2^0） = -14；
```
我选用了第三种方法